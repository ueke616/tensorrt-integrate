# 知识点
1. 对于yolov5的封装，主要考虑以下：
    - 希望调用者是线程安全的，可以随意进行commit，而不用考虑是否冲突
    - 希望结果是懒加载的，也就是需要的时候才等待，不需要的时候可以不等待
        - 由promise与future配合实现
        - 这样的灵活度和效率性能都是最好的
    - 希望最大化利用GPU，如何利用呢？需要尽可能的使得计算密集
        - 实际体现就是抓取一个批次，一次性进行推理
        - 这在内部的消费者模型里面，一次抓一批

//////////////////////////////////////////////////////////

## 在宏定义中使用 do {...} while(0) 的作用

在C和C++中，使用`do { ... } while(0)`包围的宏定义是一种常见的编程惯例，主要是为了解决宏定义在扩展时可能出现的问题，确保宏在任何地方使用都是安全的。尽管这段代码实际上只会执行一次，但这种做法有几个重要的优点：

### 1. 保证宏定义的完整性
使用`do { ... } while(0)`可以确保宏定义在使用时是一个完整的语句，避免因为宏展开后代码的不完整导致的编译错误。例如，在没有使用`do { ... } while(0)`时，如果宏定义中包含多条语句，在`if`语句中直接使用宏可能会导致编译错误或逻辑错误：

```c
if (condition)
    checkKernel(...); // 如果没有do-while，这里可能因为宏展开成多条语句导致问题
else
    // 其他操作
```

### 2. 避免悬挂`else`问题
当宏被用在`if-else`语句中时，如果没有使用`do { ... } while(0)`，可能会引发悬挂`else`问题。因为宏展开后可能包含多条语句，使得`else`子句与宏定义产生歧义。使用`do { ... } while(0)`可以确保宏定义作为一个整体被执行，避免了这个问题。

### 3. 强制使用分号
使用`do { ... } while(0)`还可以强制要求在宏调用后使用分号（`;`），这有助于保持代码的一致性和清晰性，同时避免一些因缺少分号导致的难以发现的错误。

尽管`do { ... } while(0)`在执行上看起来有些多余，但它实际上提供了一个非常有用的工具，以确保宏在不同上下文中安全、一致地展开。这种模式在C和C++中广泛应用于复杂宏的定义中，是一种很好的编码实践。

